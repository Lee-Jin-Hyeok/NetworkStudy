## IPv4

### 1. IPv4가 뭐죠?

IPv4는 OSI 7계층 중 3계층에 있는 프로토콜 중 하나이며,
다른 네트워크 대역에 존재하는 네트워크 장비와 데이터를 주고받을 수 있게 해주는 프로토콜이다.

### 2. IPv4가 하는 일

IPv4는 위에서 말했던 것처럼 다른 네트워크 대역에 존재하는 네트워크 장비와
데이터를 교환할 수 있도록 한다.

하지만 3계층의 프로토콜은 단순히 데이터를 다른 네트워크 대역으로 보내는 역할을 하기 때문에
IPv4도 마찬가지로 단순히 데이터를 보내기만 하지 데이터의 정확성을 보장하지는 않는다.
그래서 4계층의 프로토콜이 이 정확성을 보장해주는 역할을 한다.

위에 이어서 단순히 데이터만 보내기 때문에 패킷 중 중복된 패킷이 있을 수 있고
패킷의 순서가 잘못 될 수도 있다.
패킷 순서의 잘못은 상위 프로토콜인 TCP가 보장한다.

### 3. IPv4의 구조

IPv4는 총 20+a바이트로 이루어져 있으며 다음가 같이 구성되어 있다.

1. Version : 4 bit
2. IHL (IP Header Length) : 4 bit
3. TOS (Type Of Service) : 1 byte
4. Total Length : 2 byte
5. Identification : 2 byte
6. IP Flags : 3 bit [ 오타 아님 ]
7. Fragment Offset : 13 bit
8. TTL (Time To Live) : 1 byte
9. Protocol : 1 byte
10. Header Checksum : 2 byte
11. Source Address : 4 byte
12. Destination Address : 4 byte
13. IP Option : +a

그럼 각각의 요소가 무슨 역할을 하는지 알아보도록하겠다.

#### 3-1. Version : 4 bit

Version은 말 그대로 버전이 무엇인지 적는 곳인데
IP는 Version4와 Version6가 존재한다.
그런데 우리가 다루고 있는 것은 IPv4이므로 16진수로 4가 들어간다.

그렇다고 해서 IPv6를 사용하면 6이 들어가는 것은 아니다.
처음에 설계할 때는 Version이 바뀔 수록 이 수를 변경하는 것으로 설계하였으나,
IPv4와 IPv6는 내부 구조부터 완전히 다르기 때문에 이를 사용할 수 없게 되었다.
따라서 Version에는 4밖에 들어갈 수 없다.

#### 3-2. IHL ( IP Header Length ) : 4 bit

IHL은 말 그대로 IPv4의 길이를 말한다.
IPv4는 20+a byte 라고 했는데
a는 최대 40까지 커질 수 있다. ( 나중에 IP Option에서 다룬다 )
그러므로 20~60까지의 숫자가 들어갈 수 있다.

그런데 IHL의 크기는 0.5 byte, 즉 0~ 15까지의 수밖에 담을 수 없다.
그래서 IHL에 들어가는 숫자는 IP Header Length를 4로 나눈 값을 저장한다.

따라서 최대일 경우 15, 최소일 경우 5가 저장된다.
나중에 IP Option에서 다루겠지만 Option이 없는 경우가 보통이므로 대부분 5가 저장된다.

#### 3-3. TOS ( Type Of Service ) : 1 byte

결론만 말하자면 TOS는 현재 사용되지 않는 값이다.
원래는 서비스의 타입, 즉 이 데이터는 굉장히 중요한 데이터다 또는 가벼운 데이터다 라고
적어주는 그런 값이었지만 이제는 불필요성을 느끼고 사용하지 않는 값이 되었다.
그래서 이제는 이 1 byte를 모두 0으로 채워 사용하고 있다.

참고로 만약 TOS의 값을 변경하여 패킷을 보낸다고 해도
이 값을 해석할 수 있는 네트워크 장비가 없기 때문에 해석할 수도 없다고 한다.

#### 3-4. Total Length : 2 byte

Total Length는 IPv4 헤더의 길이만 구하는 것이 아니라
IPv4의 헤더의 길이와 페이로드, 그 앞의 프로토콜까지 모두 더한 값을 저장한다.
따라서 이더넷 + IPv4 + ICMP 라면 이더넷, IPv4, ICMP의 헤더의 길이를 모두 포함하는
길이를 저장한다.

#### 3-5. Identification : 2 byte

패킷의 데이터의 크기가 너무 클 때는 패킷을 조각화하여 나누어서 처리한다.
이럴 때 조각화하기 전의 원본 패킷을 복구하기 위해서
원래 같은 패킷이었던 패킷끼리는 같은 Identification 값을 가지게 된다.
따라서 Identificatiion은 유일한 값을 가지게 된다.

#### 3-6. IP Flags : 3 bit

IP Flags는 3 bit로 되어 있으며 1bit 당 하나의 뜻을 가지고 있다.

1. 첫 번째 bit (x)
   그냥 사용하지 않는다는 뜻이다.
   그러므로 항상 0의 값을 유지한다.
2. 두 번째 bit (D)
   Dont't Fragment의 약자로서,
   값이 0일 때는 데이터가 클 때 조각화를 하겠다는 뜻이고
   값이 1일 때는 데이터에 관계 없이 조각화를 하지 않겠다는 뜻이다.
   그런데 데이터가 커서 조각화를 해야하는데 이 값이 1이라면
   데이터를 전송시키지 않는다.
3. 세 번째 bit (M)
   More Fragment의 약자로서,
   값이 0일 때는 조각화 되었을 때 이 패킷 조각이 마지막 패킷 조각이라는 뜻이고
   값이 1일 때는 뒤에 조각화 된 패킷 조각이 있으니 기다리라는 뜻이다.

#### 3-7. Fragment Offset : 13 bit

Fragment Offset은 조각화 된 패킷 조각의 순서를 알려주는 값이다.
그런데 순서를 그대로 알려주지는 않고,
가장 첫 번째 값이라면 0, 두 번째 값이라면 첫 번째 패킷 조각의 크기,
세 번째 값이라면 첫 번째 패킷 조각의 크기 + 두 번째 패킷 조각의 크기,
네 번째 값이라면 첫 번째 패킷 조각의 크기 + 두 번째 패킷 조각의 크기 + 세 번째 퍀시 조각의 크기가 된다.
이렇게 앞에 존재하는 패킷 조각들의 크기를 알려주면서 순서를 지정할 수 있도록 하는 것이다.

#### 3-8. TTL (Time To Live) : 1 byte

TTL은 Time To Live의 약자로서, 패킷이 예상치 못한 루틴을 돌게 될 때 패킷을 버리도록하는 값이다.
패킷은 기본적으로 시간이 지난다고 갑자기 패킷이 죽거나 그러지는 않는다.
그런데 만약 패킷의 생존 시간이 무제한이라고 했을 때
네트워크 장비에 이상이 생겨서 무한 반복적인 루틴을 형성했다고 하자.
이렇게 되면 패킷은 계속 돌게 되면서 데이터가 쓸데 없이 쌓이게 된다.
많이 쌓인 패킷은 마치 디도스 공격처럼 많아져서 큰일이 날 수도 있다.
그래서 있는 것이 이 TTL 값이다.

TTL 값은 기본적으로 Windows 환경에서는 128의 값을 제공하고,
리눅스의 경우에는 조금씩 다르지만 64의 값을 제공한다.

이 값은 패킷이 네트워크 장비를 지날 때마다 1씩 줄어들고
0이 되면 네트워크 장비가 이를 파악하여 패킷을 버리게 된다.

#### 3-9. Protocol : 1 byte

Protocol은 IPv4의 앞에 상위 프로토콜로 무엇이 붙는지에 따라서 달라진다.
IPv4에 붙을 수 있는 상위 프로토콜은 같은 계층인 ICMP, 4계층인 TCP, UDP가 있다.
ICMP일 경우에는 01, TCP의 경우에는 06, UDP의 경우에는 11(10진수로 17)이다.

#### 3-10. Header Checksum : 2 byte

Checksum에 관한 것은 나중에 자세히 다루겠지만 간단하게 보자면,
원래 패킷에 들어있던 값들이 손실되거나 훼손되어 데이터가 사라지지는 않았는지
테스트하기 위해서 존재하는 값이다.

#### 3-11. Source Address : 4 byte

 Source Address는 지금까지 그래왔듯 이 패킷을 보내는 출발지의 IP 주소를 저장한다.

#### 3-12. Destination Address : 4 byte

Destination Address도 지금까지 그래왔듯 이 패킷을 받는 목적지의 IP 주소를 저장한다.